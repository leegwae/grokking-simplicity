# 액션과 계산, 데이터의 차이는 무엇인가

## 데이터

데이터(data)는 이벤트에 대해 기록한 사실이다. 정적이며 해석이 필요하다.

- 자바스크립트에서는 데이터를 기본 데이터 타입(숫자, 문자, 배열, 객체 등)으로 구현한다.
- (TODO; 6장, 7장) 불변 데이터 구조를 만들기 위해 카피-온-라이트(copy-on-writes)와 방어적 복사(defensive copy) 원칙을 사용한다.
- 데이터의 장점은 아래와 같다.
  1. 직렬화된 데이터는 이후의 동작을 보장할 수 있다(전송하거나, 메모리에 쓰고 읽기 좋다). 그러나 액션과 계산은 직렬화한 이후의 동작을 보장할 수 없다.
  2. 데이터는 동일성을 비교하기가 쉽다. 액션과 계산은 그렇지 않다.
  3. 데이터는 자유롭게 해석할 수 있다. 예를 들어 접속 로그는 문제 해결에 쓰일 수도 있지만 모니터링에 쓰일 수도 있다.

- 데이터의 단점은, 데이터만으로는 할 수 있는 것이 없다는 거다. 데이터는 해석해야만 의미가 있으나 계산은 해석하지 않아도 실행할 수 있다.
- 사용자나 다른 엔티티도 이벤트에 대한 사실인가? 그렇다. 데이터베이스에 저장된 사용자 이름은 `create user`와 같은 일종의 이벤트(웹 요청)로부터 생긴 것이다.

## 계산

계산(calculation)은 입력으로 출력을 계산하는 것이다. 언제나 동일한 입력에 대해서는 동일한 출력을 낸다.

- 계산은 순수 함수(pure functions), 수학 함수(mathematical function)라고도 한다.
- 계산은 참주 투명(referentially transparent)하다. 계산을 호출하는 코드를 계산 결과로 바꿀 수 있기 때문이다(자바스크립트에서, 함수 호출과 함수의 반환값은 논리적으로 동치이다).
- 자바스크립트에서는 계산을 함수로 구현한다.
- 액션의 장점은 아래와 같다.
  1. 테스트하기 쉽다.
  2. 정적 분석하기 쉽고 이를 자동화하는 것도 쉽다.
  3. (TODO; 14장) 계산끼리 조합하기 쉽다. 일급(high-order) 계산을 사용한다.
- 계산의 단점은 실행하기 전에 어떤 일이 발생할지 알 수 없다는 거다. 이는 액션도 마찬가지이다. (물론 코드를 읽으면 예상할 수는 있지만, 함수는 실행해야만 런타임에 그 결과를 알 수 있다.)

## 액션

액션(action): 외부 세계에 영향을 주거나 받는 것을 말한다. 실행 시점과 횟수에 의존한다. 첫번째 호출과 두번째 호출은 다르다. 어제의 호출과 오늘의 호출은 다르다.
- 부수 효과(side-effects), 부수 효과가 있는 함수(side-effecting functions), 순수하지 않는 함수(impure function)라고도 한다.
- 액션을 잘 사용하는 방법은 아래와 같다.
  1. (TODO; 15장) 액션을 가능한 한 적게 사용한다.
  2. 액션은 가능한 한 작게 만든다.
  3. (TODO; 18장) 액션이 외부 세계와 상호작용하는 것을 제한한다. 데이터와 계산이 안쪽에, 액션이 가장 바깥쪽에 있는 구조(어니언 아키텍처; onion architecture)로 만든다.
  4. 액션이 호출 시점과 횟수에 덜 의존하도록 한다.




"장보기" 과정을 액션, 계산, 데이터로 나누어보자. 우선, 장보기 과정은 아래와 같은 액션으로 이루어진다.

```
냉장고 확인하기 -> 필요한 것 구입하기
```

- `냉장고 확인하기`는 액션이다. 냉장고를 확인하는 시점에 따라 냉장고에 있는 재고가 다를 수 있기 때문이다.
  - 여기서, `현재 재고`(냉장고에 있는 재고)라는 데이터가 있다.
- `필요한 것 구입하기`는 액션이다. 구입하는 시점에 따라 필요한 재고가 다를 수 있고, 구입한 이후 냉장고에 있는 재고도 달라지기 때문이다.
  - 여기서, `필요한 재고`라는 데이터가 있다. 그런데 필요한 재고 중 현재 재고는 구입하지 않아도 된다.
  - 따라서 `(필요한 재고) - (현재 재고)`라는 계산과 이 계산으로 얻은 `구입할 재고 목록`이라는 데이터가 있다.



## 알게 된 것

1. `데이터 -> 계산 -> 액션`순으로 구현하도록 한다. 데이터는 사용하는 데 제약이 많고, 액션은 가장 제약이 없기 때문이다.

2. 최적화를 한다해도 계산은 바뀌는 일이 없어야한다.
   ```javascript
   // 예를 들어, 아래와 같이 데이터베이스로부터 사용자의 배열을 가져와 사용자에게 이메일 보내는 함수가 있다고 하자.
   function sendEmails() {
     const users = fetchUsersFromDB();	// 액션
     const emails = emailsForUsers(users);	// 계산
     for (let i = 0; i < emails.length; i++) {
       const email = emails[i];
       emailSystem.sendEmail(email);	// 액션
     }
   }
   
   // users가 수백만명이라면 메모리가 부족할 수도 있다. 그렇다면 users를 20명씩만 가져고 이메일을 보내는 동작을 반복하게 하면 되겠다.
   function sendEmails() {
     let page = 0;
     let users = fetchUsersFromDB(page);	// 액션을 수정한다.
     while (users.length > 0) {
       const emails = emailsForUsers(users);	// 계산은 수정하지 않는다.
       for (let i = 0; i < emails.length; i++) {
         const email = emails[i];
         emailSystem.send(email);
       }
       
       page += 1;
       users = fetchUsersFromDB(page);
     }
   }
   ```

## 스터디

### 연습문제 p.40

- 이메일 데이터베이스 확인하기(A)
  - 사용자 목록 가져오기(A)
  - 추천횟수가 10 미만인 사용자 목록 가져오기(A)
  - 사용자 목록 - 추천횟수가 10 미만인 사용자 목록(C)
  - 추천횟수가 10 이상인 사용자 목록(D)
- 쿠폰 데이터베이스 확인하기(A)
  - 쿠폰 목록 가져오기(A)
  - 등급이 Best가 아닌 쿠폰 목록 가져오기(A)
  - 쿠폰 목록 - 등급이 Best가 아닌 쿠폰 목록 (C)
  - 등급이 Best인 쿠폰 목록(D)
- 이메일 보내기(A)
  - 추천횟수가 10 이상인 사용자 목록 에게 등급이 Best인 쿠폰 목록 보내기

### 연습문제 p.41

- **쿠폰에 등급 매기기는 왜 데이터인걸가?** 나는 계산이라고 생각했다. 쿠폰에 등급을 부여하는 정책이 데이터로서 있고, 해당 정책과 쿠폰을 받아 등급을 반환한다고 생각했다.
  - => p.45 이후를 읽어보니, "쿠폰 등급 결정하기"는 특정 구독자에 대하여 이 구독자가 받을 쿠폰의 등급을 결정하는 것이다.
  - => 그렇다면 더더욱 계산이 아닌가? 구독자를 입력으로 받아서 쿠폰의 등급을 계산하니까.
- **어떤 이메일이 쿠폰을 받을지 결정하기는 왜 계산인걸까?** 나는 액션이라고 생각했다. 같은 이메일이더라도 시간에 따라(보내는 시점에서는 사용자가 추천한 수가 10을 넘을 수도 있고 넘지 않을 수도 있다) 쿠폰을 받을 수도 있고 받지 않을 수도 있다고 생각했다.
  - => 뭔가 명확하지 않은 거 같은데 이후의 다이어그램에서는 안나오니 그냥 신경 안 쓰는 게 나을 수도



### 논의하고 싶은 것

사용자에게 이메일을 보내는 예시 코드는 간략화하면 아래와 같이 작성되어있다.

```javascript
const subscribers = fetchSubscribersFromDB();
const emails = emailsForSubscribers(subscribers);
for (let i = 0; i < emails.length; i++) {
  const email = emails[e];
  emailSystem.send(email);
}
```

나는 위와 같은 구현이 적절하지 않다고 생각했다. 왜냐하면, 효율적이지 않기 때문이다. `subscribers`가 `n`이면 `emails`도 `n`이다. `emails`를 구할 때 이메일을 보내지 않고 굳이 `emails` 배열을 반환하는 함수를 만들어 시간복잡도를 높힌 것이 이해가 가지 않았다. 아래와 같은 구현이 적절하다고 생각했다.

```javascript
const subscribers = fetchSubscribersFromDB();
for (let i = 0; i < subscribers.length; i++) {
  const email = emailForSubscriber(subscriber);
  emailSystem.send(email);
}
```

그런데 이 챕터에서 배운 것을 토대로 하면, 어느 코드가 더 나을까?
